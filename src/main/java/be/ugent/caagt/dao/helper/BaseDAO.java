/*
 * BaseDAO.java
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * Copyright Â© 2016-2024 Kris Coolsaet (Universiteit Gent)
 *
 * This software is distributed under the MIT License - see files LICENSE and AUTHORS
 * in the top level project directory.
 */

package be.ugent.caagt.dao.helper;

import be.ugent.caagt.dao.DataAccessException;
import be.ugent.caagt.dao.ForeignKeyViolation;
import be.ugent.caagt.dao.NotNullViolation;
import be.ugent.caagt.dao.UniqueViolation;

import java.sql.*;
import java.time.*;
import java.util.Arrays;
import java.util.List;

/**
 * Base class from which your DAO classes should be derived
 */
public abstract class BaseDAO {

    private BaseDAC context;

    /**
     * Returns a connection for use with this DAO.
     */
    protected Connection getConnection() {
        return context.getConnection();
    }

    /**
     * Create a data access object for the given context
     */
    protected BaseDAO(BaseDAC context) {
        this.context = context;
    }

    // only for testing
    BaseDAO() {
    }

    // only for testing
    void setContext(BaseDAC context) {
        this.context = context;
    }

    protected BaseDAC getContext() {
        return context;
    }

    static DataAccessException convert(SQLException ex) {
        String sqlState = ex.getSQLState();
        if (sqlState == null) {
            return new DataAccessException(ex);
        } else {
            return switch (sqlState) {
                case "23502" -> new NotNullViolation(ex);
                case "23503" -> new ForeignKeyViolation(ex);
                case "23505" -> new UniqueViolation(ex);
                default -> new DataAccessException(ex);
            };
        }
    }

    /**
     * Creates a call for the current connection
     */
    protected CallableStatement prepareCall(String call) throws SQLException {
        return getConnection().prepareCall(call);
    }

    /**
     * Creates a prepared statement for the current connection
     */
    protected PreparedStatement prepareStatement(String sql) throws SQLException {
        return getConnection().prepareStatement(sql);
    }

    /**
     * Creates a prepared statement which allows retrieval of an autogenerated key
     */
    protected PreparedStatement prepareAutoGenerated(String sql) throws SQLException {
        return getConnection().prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
    }

    /**
     * Creates an insert statement
     */
    public InsertSQLStatement insertInto(String table) {
        return new InsertSQLStatement(table, context);
    }

    /**
     * Creates an 'upsert' statement
     */
    public UpsertHeader insertOrUpdateInto(String table) {
        return new UpsertHeader(table, context);
    }

    /**
     * Creates a delete statement
     */
    public UpdateOrDeleteSQLStatement deleteFrom(String table) {
        return new UpdateOrDeleteSQLStatement("DELETE FROM " + table, context);
    }

    /**
     * Creates an update statement
     */
    public UpdateSQLStatement update(String table) {
        return new UpdateSQLStatement(table, context);
    }

    /**
     * Creates a select statement
     */
    public SelectHeader select(String fields) {
        return new SelectHeader(fields, context);
    }

    /**
     * Creates the intersection of the given list of queries
     */
    public Intersection intersection(List<SelectSQLStatement> list) {
        return new Intersection(list, context);
    }

    /**
     * Creates the intersection of the given queries
     */
    public Intersection intersection(SelectSQLStatement... args) {
        return new Intersection(Arrays.asList(args), context);
    }


    /**
     * Creates a general sql statement. Only use this when {@link #insertInto}, {@link #deleteFrom}, {@link #update}
     * or {@link #select} cannot be used.
     */
    public GeneralSQLStatement sql(String stat) {
        return new GeneralSQLStatement(stat, context);
    }

    /**
     * Creates a call of a stored procedure. For functions, use select.
     */
    public SQLProcedureCall call(String stat) {
        return new SQLProcedureCall(stat, context);
    }

    /**
     * Helper method to retrieve a local date from a result set. The corresponding database column must
     * be of type DATE.
     */
    public static LocalDate getLocalDate(ResultSet rs, String columnName) throws SQLException {
        return rs.getObject(columnName, LocalDate.class);
    }

    /**
     * Helper method to retrieve a local date from a result set. The corresponding database column must
     * be of type DATE.
     */
    public static LocalDate getLocalDate(ResultSet rs, int index) throws SQLException {
        return rs.getObject(index, LocalDate.class);
    }

    /**
     * Helper method to retrieve a local time from a result set. The corresponding database column must
     * be of type TIME.
     */
    public static LocalTime getLocalTime(ResultSet rs, String columnName) throws SQLException {
        return rs.getObject(columnName, LocalTime.class);
    }

    /**
     * Helper method to retrieve a local time from a result set. The corresponding database column must
     * be of type TIME.
     */
    public static LocalTime getLocalTime(ResultSet rs, int index) throws SQLException {
        return rs.getObject(index, LocalTime.class);
    }

    /**
     * Helper method to retrieve a local date time from a result set. The corresponding database column must
     * be of type TIMESTAMP (without timezone).
     */
    public static LocalDateTime getLocalDateTime(ResultSet rs, String columnName) throws SQLException {
        return rs.getObject(columnName, LocalDateTime.class);
    }

    /**
     * Helper method to retrieve a local date time from a result set. The corresponding database column must
     * be of type TIMESTAMP (without timezone).
     */
    public static LocalDateTime getLocalDateTime(ResultSet rs, int index) throws SQLException {
        return rs.getObject(index, LocalDateTime.class);
    }

    /**
     * Helper method to retrieve an instant from a result set. The corresponding database column must
     * be of type TIMESTAMP WITH TIMEZONE.
     */
    public static Instant getInstant(ResultSet rs, String columnName) throws SQLException {
        OffsetDateTime value = rs.getObject(columnName, OffsetDateTime.class);
        return value == null ? null : value.toInstant();
    }

    /**
     * Helper method to retrieve an instant from a result set. The corresponding database column must
     * be of type TIMESTAMP WITH TIMEZONE.
     */
    public static Instant getInstant(ResultSet rs, int index) throws SQLException {
        OffsetDateTime value = rs.getObject(index, OffsetDateTime.class);
        return value == null ? null : value.toInstant();
    }

    /**
     * Create a composite where clause
     */
    protected CompositeWhereClause compositeWhereClause() {
        return context.compositeWhereClause();
    }

}
